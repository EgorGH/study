A 
1) заменить сортировку вставками на qsort;
2) tpred -> tpredecessors
3) ничего лишнего в answer/answer_slow быть не должно, только то, что позволяет получить ответ
4)  if (x >= 0) and (y >= 0) and (x <= 25) and (y <= 25)
5) destination -> data
6) fill_predecessors -> optimal_search
7) аналогично исправить остальные проекты

B
1) убрать лишнее
2) из full_search убрать аспекты, не относящиеся к поиску
3) убрать лишнее из optimal_search
4) analyze не отражает то, что делает функция и что она возвращает
5) в случае a*d=b*c можно подобрать точку старта оптимальнее, чем 0
6) реализовать алгоритм, указанный в vk

C
1) выделение памяти (и по возможности заполнение нулями) должно происходить в основной программе

D
1) реализовать оптимальное решение
2) реализовать тест

E
1) вынести full_search из optimal_search, оставить только аспект кеширования
2) создать еще один проект, назвать cashed_search, перенести туда оптимизацию кешированием
3) реализовать optimal_search динамическим программированием (обход дерева снизу вверх)

F
1) answer должен получаться из test простым копированием с удалением лишнего
2) тест должен тестировать все N от 0 до MaxN по одному разу

G
1) реализовать test для answer (проверяет непротиворечивость и количество)
2) реализовать test для answer_slow (проверяет непротиворечивость и количество)
3) реализовать функцию, которая принимает строку и возвращает тип Episode
